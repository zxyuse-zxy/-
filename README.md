目录
一、JAVA基础	1
二、多线程并发编程	4
三、JVM	7
四、计算机网络	9
五、操作系统	11
六、数据库	15
七、Redis	19
八、Spring	23
九、仿牛客项目总结	25


一、JAVA基础
1. JVM vs JDK vs JRE
JVM java虚拟机 来屏蔽java 代码与底层操作系统的差异，使得到处运行
JRE  java运行环境，就是jvm+基础类库
JDK  jvm+基础类库+编译工具
有了JVM .class文件能够被解释成机器码
有JRE .class文件能够执行
有JDK 才能编译程序，调试代码进行开发
2. 包装类型与基本类型区别
   包装类型可以为null，基本数据类型不可以（数据库查询时，如果对查询结果直接赋值为空，那么基本数据类型会返回异常）
   包装类型可用于泛型，基本类型不可以  泛型在编译时会进行类型擦除，只保留原始类型，原型只能时Object类及其子类，基本类型会编译报错
   基本类型比包装类型更高效。 包装类型存储的是堆中的引用 
3. 自动装箱与拆箱
Integer i = 10; //装箱 将基本类型用引用类型包装起来 其实隐式调用了Integer.valueOf (I)
int n = i; //拆箱 隐式调用Integer.intValue ()
注：包装类型有缓存机制
Byte , Short , Integer , Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据， Character 创建了数值在 [0,127] 范围的缓存数据， Boolean 直接返回 True or False
自动装箱时，数值在此范围内直接返回缓存中的对象，超过范围，创建新对象
4. 浮点数运算精度丢失----> BigDecimal
5. 超过 long 整型的数据---> BigInteger
6. ⾯向对象三⼤特征
封装  继承  多态
多态：具有继承关系的不同对象，把他们的指针扔进相同函数，利用动态联编实现指向不同对象的方法
编译器时静态联编，不可能实现多态，只会找到基类函数的入口地址
多态就需要在运行时，动态联编
7. 深拷⻉和浅拷⻉
浅拷⻉：浅拷⻉会在堆上创建⼀个新的对象（区别于引⽤拷⻉的⼀点），不过，如果原对象内部的属性是引⽤类型的话，浅拷⻉会直接复制内部对象的引⽤地址，也就是说拷⻉对象和原对象共⽤同⼀个内部对象。 深拷⻉ ：深拷⻉会完全复制整个对象，包括这个对象所包含的内部对象。
引⽤拷⻉: 两个不同的引⽤指向同⼀个对象


8. 对于基本数据类型来说, == ⽐的是值。 
对于引⽤数据类型来说, == ⽐的是对象的内存地址
9. 
equals ⽅法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。 
两个对象有相同的 hashCode 值，他们也不⼀定是相等的（哈希碰撞）。

10. String、StringBuffer、StringBuilder
1. 可变性， String内部的value值被final所修饰，所以String是不可变类，每次修改String值使都会产生新对象，StringBuffer 和 StringBuilder都是可变的
2. 安全性， 
String 中的对象是不可变的，也就可以理解为常量，线程安全。 
StringBuffer 对⽅法加了同步锁或者对调⽤的⽅法加了同步锁synchronized，所以是线程安全的。
StringBuilder并没有对⽅法进⾏加同步锁，所以是⾮线程安全的。多线程对字符串操作时，使用StringBuffer类
3. 性能方面， String最低, 其次StringBuffer，最好的时StringBuilder
4. 存储，String在常量池中 后两者在堆内存中

String 重载+ 和 += 实现字符串的拼接。实质上是创建了一个StringBuilder并调用其append()，拼接之后toString().
如果循环+进行字符串拼接，会不断创建StringBuilder对象，造成内存浪费。
11. 字符串常量池
	目的：是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专⻔开辟的⼀块区域， 主要⽬的是为了避免字符串的重复创建
	String s1 = new String("abc")
	1. 如果字符串常量池中不存在字符串对象“abc”的引⽤，那么会在堆中创建 2 个字符串对象“abc”,并把字符串”abc”的引用保存在字符串常量池中
2. 如果字符串常量池中已存在字符串对象“abc”的引⽤，则只会在堆中创建 1 个字符串对象“abc”
String的 + 运算
1. 常量字符串 + 操作 String str3 = "str" + "ing"; 在编译时会进行常量折叠 String str3 = "string";
   随后将string加入到常量池中
2. 对象引⽤ + 操作 String str4 = str1 + str2  StringBuilder.append.toString
   产生一个新的对象
3. 如果String 用final修饰 String 会被编译器当做常量来处理 就变成第一种情况
12. Exception 和 Error
Exception程序本身可以处理的异常，可以通过 catch 来进⾏捕获。 Exception ⼜可以分为 编译时异常和运行时异常
Error 属于程序⽆法处理的错误，比如内存溢出，就会线程终止
捕获异常：try-catch-finally
1. ⽆论是否捕获或处理异常， finally 块⾥的语句都会被执⾏。当在 try 块或 catch 块中遇到 return 语句时， finally 语句块将在⽅法返回之前被执行。
2. finally不⼀定执行， 程序所在的线程死亡或者CPU关闭
3. finally 语句块中不能使⽤ return。当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。
13. 涉及读写时， try-with-resources代替try-catch-finally实现自动关闭资源
14. 反射可以在程序运行的过程中去构造任意一个类对象并且可以获取任意一个类的成员变量，成员方法和属性以及调用任意一个对象方法。
优点：1. 增加程序的灵活性，可以在运行的过程中动态对类进行修改和操作
	  2. 提高代码的复用率，比如动态代理,就是用到了反射来实现
3. 可从在运行时轻松获取任意一个类的方法、属性，并且还能通过反射进行动态调用
缺点：1. 反射会涉及到动态类型的解析，所以JVM无法对这些代码进行优化，导致性能要比非反射调用更低。
2. 使用反射以后,代码的可读性会下降
3. 反射可以绕过一些限制访问的属性或者方法，可能会导致破坏了代码本身的抽象性
反射可以在程序运行的过程中去构造任意一个类对象并且可以获取任意一个类的成员变量，成员方法和属性以及调用任意一个对象方法。
使用场景: 1.动态代理场景中 使用动态生成的代码类提升代码复用性
		 2.Spring框架中使用反射实例化Bean对象
SPI 即 Service Provider Interface ，字⾯意思就是：“服务提供者的接⼝
15. SPI 和 API 有什么区别？	
接口调用方确定接口规则，然后由 不同厂商根据这一规则对接口进行实现，从而提供服务,这是 SPI
	实现方提供接口和实现，调用方直接调用，这是API
16. 序列化与反序列化
序列化： 将数据结构或对象转换成⼆进制字节流的过程 
反序列化：将在序列化过程中所⽣成的⼆进制字节流转换成数据结构或者对象的过程
应用场景：把Java 对象保存在⽂件或者是在网络中传输Java对象
注：1. 不想序列化的成员变量前面加关键字transient 在反序列化后变量值将会被置成类型的默认值 
2. static 变量属于类不属于对象，不会被序列化
17.  IO流为什么分字节流和字符流
字节流：可操作所有类型的文件
	字符流：字节流加上字符集，可以操作纯文本文件
	如果只有字节流进行文本传输， 首先字符需要虚拟机从子节进行转换，比较耗时。其次，不知道编码类型会出现乱码。字符流：字节流加上字符集，可以操作纯文本文件
18. 常见的IO模型  BIO  NIO  AIO
19.  Java 集合组成
Collection 接口派生：单一元素 Set List Queue
Map接口派生：键值对
20. List, Set, Queue, Map 四者的区别
List(对付顺序的好帮手): 存储的元素是有序的、可重复的。
Set(注重独一无二的性质): 存储的元素不可重复的。
Queue(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。
 Map: 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值
21. ArrayList 的扩容机制
1.利用空参创建的集合，在底层创建一个默认长度为0的数组
2.添加第一个 元素时，底层会创建一个新的长度为10的数组
3.存满时，会扩容1.5倍
4.如果一次添加多个元素，1.5倍放不下，则新创建的数组以实际为准 
23. HashMap
	1. 怎么解决哈希冲突
	   HashMap底层采用了数组结构来存储数据元素，数组的默认长度是16.当我们通过put方法添加键值对时，HashMap会根据key的哈希值进行取模运算，最终把这些值保存在数组的指定位置，但是两个不同哈希值的Key取模之后可能相等，这就造成了哈希冲突。为了解决哈希冲突，HashMap引入了链式寻址法，把存在冲突的key组成单向链表，挂在数组之下。为了避免链表过长导致的查询效率降低，在链表长度大于8 且数组长度大于64时，链表自动转为红黑树。
	   哈希冲突还可以采用再hash，用一个hash进行计算，开放寻址法，直接从冲突位置向下找一个空着的数组下标，或者建立公共溢出区，将存在冲突的key进行一个统一存放。
2. HashMap扩容机制
		1. 创建一个默认长度为16， 加载因子0.75的数组
		2. 元素个数达到阈值（容量*0.75），数组扩容为之前的两倍
		3. 链表长度大于8 且数组长度大于64时，链表自动转为红黑树

	3. 线程下使用 HashMap 会存在数据覆盖的问题,可以使用 ConcurrentHashMap.

23. ConcurrentHashMap底层实现原理
	1. ConcurrentHashMap他的架构跟HashMap是一致的，由数组，链表和红黑树组成。HashMap扩容机制
	2. 相较于HashMap，ConcurrentHashMap通过加锁实现了并发安全。
3. ConcurrentHashMap的优化
(1)在jdk1.8中缩小了锁粒度，只锁定node节点
(2)引入多线程并发扩容，简单来说就是多个线程对原始数组进行分片，每个线程负责一个分片的数据迁移，从而整体提升扩容的效率
(3)利用CAS进行元素个数的更新
二、多线程并发编程
1. 进程与线程
进程 是程序的一次执行，是操作系统进行资源分配和调度的一个基本单位
线程 是操作系统执行的最小单位 
进程之间相互独立，⼀个进程在其执⾏的过程中可以产⽣多个线程。多个线程共享进程的堆和⽅法区资源，但每个线程有⾃⼰的程序计数器、 虚拟机栈和本地⽅法栈，各个线程之间作切换⼯作时，负担要⽐进程⼩得多。
2. 什么时候使用多进程，什么时候使用多线程
1.频繁修改：需要频繁创建和销毁的优先使用多线程 
2.计算量：需要大量计算的优先使用多线程 因为需要消耗大量CPU资源且切换频繁，所以多线程好一点 
3.相关性：任务间相关性比较强的用多线程，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。 
4.多分布：可能要扩展到多机分布的用多进程，多核分布的用多线程。 但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。
3. 线程的生命周期
	1.创建
	2.就绪 获得除处理器之外的所有资源
	3.执行 获得cpu资源执行， 
情况一：时间片用尽 返回就绪状态
情况二：IO请求 进入阻塞状态，请求结束后进入就绪状态
情况三：运行完毕，进入中止状态
4. 多线程的创建方式
	1. 继承Thread类， 重写run方法，创建子类对象，启动线程  无返回结果
	2. 实现Runnable接口，实现run方法，创建自己类的对象，创建一个Thread类对象，把类对象传递给线程，开启线程   无返回结果
	3. 创建实现Callable接口的任务类，重写有返回值的call方法。创建FutureTask对象管理多线程运行的结果，创建一个Thread类对象，开启线程。返回值用ft.get( )    有返回结果

注： 三种方法实质上都是对Runnable接口的实现
5. 为什么不可以直接调用Thread类的 run方法
直接执行run方法，就会执行main线程下的一个普通方法，而不是多线程工作。调用start方法才会启动一个线程进入就绪状态

6. sleep() 方法和 wait() 方法对比
两者都可以暂停线程的执行。但是目的不一样。sleep() 是让当前线程暂停执行，Thread 类的静态本地方法。wait()用于线程之间的交互，通过调用wait()实现让获得对象锁的线程等待，并且释放当前线程占有的对象锁，线程需要与锁对象进行绑定，随后被锁对象唤醒，所以他是wait() Object 类的本地方法。sleep()方法执行完成后，线程会自动苏醒。wait（）方法调用后，线程不会自动苏醒，需要被唤醒
7. 什么是守护线程
	当其他的非守护线程执行完毕之后，守护线程也会陆续结束。
	应用场景：聊天框与传输文件，传输文件就是守护线程，关闭聊天框，传输文件线程自动结束
8. 死锁必要条件
（1）互斥条件：即某个资源在⼀段时间内只能由⼀个进程占有，不能同时被两个或两个以上的进程占有
（2）不可抢占条件。进程所获得的资源在未使⽤完毕之前，资源申请者不能强⾏地从资源占有者⼿中夺取资源， ⽽只能由该资源的占有者进程⾃⾏释放。
（3）占有且申请条件。进程⾄少已经占有⼀个资源，但⼜申请新的资源；由于该资源已被另外进程占有，此时该 进程阻塞；但是，它在等待新资源之时，仍继续占⽤已占有的资源。
（4）循环等待条件：进程之间形成循环等待关系。
9. 避免死锁
（1）资源一次性分配，从而解决请求保持的问题
（2）可剥夺资源：当进程新的资源未得到满足时，释放已有的资源；
（3）资源有序分配：资源按序号递增，进程请求按递增请求，释放则相反。
10.  synchronized 关键字 
	主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。
注： 同步方法就是把synchronized放在方法修饰词后面，这里不需要自己加锁，默认加锁
11  synchronized与lock的区别
	1. 两者都是解决线程安全的工具， synchronized是java关键字， lock是一个接口。
	2. synchronized通过将关键字修饰在方法上或者是代码块上控制锁粒度。lock的相比较更为灵活，通过lock 与 unlock方法进行锁粒度的控制
3.lock提供了非阻塞的竞争锁的方法，通过trylock方法去获取是否有线程正使用锁。并且lock提供了公平锁和非公平锁机制，所谓公平锁，先申请的线程先得到锁。非公平锁就是随机或者按照其他优先级排序的获得锁。Synchronized只提供非公平锁。
12. 什么是阻塞队列
阻塞队列是应用在消费者和生产者模式中的一种特殊队列。它增加了两个功能，一个是队列为空，阻塞消费者线程并唤醒生产者线程。但队列满了的时候，堵塞生产者线程，唤醒消费者线程。阻塞队列中的元素个数通常是有限的，比如底层用数组实现的ArrayBlockList，但是可以使用链表的形式，被称为无界，但是它不是真正的无界，他的默认队列长度是Integer.Max.value。
13. 悲观锁与乐观锁
	背景：在多线程的背景下，实现对共享变量读写出错。
	悲观锁： 每次在获取资源操作的时候都会上锁，比如synchronized和ReentrantLock，性能损耗比较大
	乐观锁：不加锁不等待直接用，在提交修改的时候去验证数据是否被其他线程修改
1. 版本号机制， 给数据表增加一个版本号字段，每修改一次，版本号加一，线程A读取数据时会同时读取版本号，提交跟新数据时，会比较现在的版本号跟之前读取的版本号是否一致，如果不一致，则说明数据已经被更改，那么重试更新。
2. CAS（compareAnd Swap）比较并交换的意思。这是一个原子操作，不会被打断。获取变量当前值与更新前的原值进行比较，如果相等，那么就将内存中的变量值进行更新。
存在问题 1： 多个线程CAS自旋更新，每次只有一个能胜出，其他失败继续尝试，长时间不成功会给CPU带来很大的执行开销
				 2： ABA问题 解决办法是加版本号，或者是时间戳
14. 线程池
作用：
1. 可以减少线程频繁创建和销毁带来的性能开销，因为线程创建会涉及到CPU上下文切换，内存分配等工作。
2. 线程池本身会有参数控制线程创建的数量，这就可以避免无休止的创建线程，起到资源保护的作用
核心原理
创建一个线性池，提交任务，池子会创建新的线程对象，任务执行完毕，线程返还给池子，下次在提交任务时，直接复用已有线程。如果提交任务时，池子中没有空闲线程，也无法创建新的线程，任务就会排队等待。
线程池常见参数有哪些？
1. 核心线程数量  创建好后会一直存在直到关闭线程池
2. 最大线程数    最大线程数-核心线程数就是临时线程数
3. 临时线程存活时间
4. 阻塞队列   当核心线程都在工作时，任务被添加到阻塞队列中，任务队列已满，但是线程数没有到达上限，就会新建临时线程执行任务
5. 如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，线程池执行饱和策略，比如说抛出异常拒绝新任务，也可以将任务丢弃，退还等
线程池大小设置
CPU密集型  计算比较多  CPU 核心数+1 
I/O密集型  读取文件比较多  2*N（CPU核心数）
15. ThreadLocal 
	作用：ThreadLocal是一种线程隔离机制。保证了在多线程的环境下对共享变量访问的一个安全性 。我们可以通过加锁进行线程隔离，但是会降低性能。ThreadLocal使用空间换时间的思想。在每一个线程中都有一个容器，存储共享变量的一个副本。那么每一个线程只对自己的变量副本进行更新操作，从而解决线程安全问题。具体实现原理是Thread类中都有一个ThreadLocalMap的变量进行存储。
ThreadLocal 内存泄露问题
ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，在垃圾回收的时候，会被清理掉，就会出现ThreadLocalMap 中key 为 null 的 Entry，这块内存永远不会被访问，出现内存泄漏的问题。最好在调用ThreadLocal方法后，手动进行remove（）
16. CompletableFuture的理解
CompletableFuture是基于事件驱动的异步回调类，简单来说，就是使用异步线程执行任务时，我们希望任务结束后能够自动触发一个后续的动作。举一个简单的例子，我们购物的时候，查询订单，支付，返回订单，这是一个顺序的过程，使用同步效率很低。我们就可以使用异步线程处理，使用CompletableFuture查询订单后出发支付操作，在完成支付任务后触发返回订单任务。
17. JMM是什么
JMM java 内存模型， 为了简化多线程编程，增强程序可以执行定义的一组原则与规范。
这其实涉及到了两个问题，一个是CPU多级缓存模型，内存中的数据就先被读进缓存中，CPU直接处理缓存中的数据，再写回内存，在多线程的背景下，存在内存缓存不一致的情况。
为解决这一问题，使用volatile关键字修饰的共享变量，在数据修改后，将修改后的数据立即写回系统内存，并且写回操作会开启MESI缓存一致性协议，其他CPU通过总线嗅探机制感知数据变化更新缓存中的数据
第二个问题是指令重排序。为了提高执行的速度和性能，计算机执行代码时会调整语句执行顺序。在多线程下，可能会出现错误。程序员基于happens-before规则提供的内存可见性来编程，可以实现程序员和编译器和处理器之间的平衡，也就是除了一定不能改变的，其他任由编译器和处理器优化
解决办法：使用volatile关键字声明变量，对此变量进行读写操作时，会通过插入特性内存屏障的方式禁止指令重排序
18. AQS的理解
AQS是多线程同步器，是众多同步组件的底层实现。本质上AQS提供了两种锁机制，排他锁和共享锁。ReentrantLock重入锁就是用到了AQS的排他锁的功能，在多个线程去获取共享资源时，只有一个线程能获得锁。共享锁又称为读锁，同时多个线程获取资源锁，比如说信号量。当共享资源被占用，AQS将未获得锁的线程加入到一个双向链表中进行阻塞，当获得共享资源的锁释放之后，会重双向链表的头部唤醒下一个等待的线程，再进行竞争。
19. 类加载器
类加载就是把java文件编译之后形成的.class文件加载到JVM内存中，之后就可以通过new关键字进行对象的实例化。类加载的过程是类加载器执行的。JVM内置了三个不同层级的类加载器， 启动类加载器， 最顶层的类加载器，加载java的核心类库， 扩展类加载器，应用类加载器，当前应用路径下的jar包。
实际加载中使用双亲委派模型，按照类加载器的层级关系， 自底向上判断该类就否被加载， 自顶向下尝试加载类。好处是避免重复加载，以及安全性，这张层级关系代表着优先级，核心类中的类没有办法被破坏。我们自己写了一个java.lang.String, 最终加载的还是核心类库中的jar包
20 如何破坏双亲委派模型
	1. 需要继承 ClassLoader ， 重写 loadClass()方法
	2. 使用线程上下文加载， 使用Thread类中的setContextClassLoader方法设置当前类类加载器类型
三、JVM
1. 什么是Java虚拟机，为什么要用
Java虚拟机时Java语言的运行环境，可以屏蔽java代码与底层操作系统的差异，使得一次编写，到处运行。我们可以将Java虚拟机比作翻译工具。JVM还支持自动内存管理以及垃圾回收功能，减少了程序开发的复杂性。
2. JVM的内存结构
JVM在执行java程序时将它管理的部分划分为两个部分
线程私有部分 程序计数器， 虚拟机栈， 本地方法栈
线程共享的 堆， 方法区以及直接内存
3. 什么是方法区
方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。这是一个定义，具体实现有jdk1.8之前的永久代和jdk1.8之后的元空间。永久代处于JVM的堆中，是有内存上限的，元空间在本地内存中，内存溢出的几率更小。
为了提高性能减少内存消耗，JVM创建了字符串常量池，并且放于永久代，但是永久代的GC是Full GC，回收效率低，不能及时把不适用的字符串进行回收，所以在jdk1.7 字符串常量池被转移到了堆中。
4. 什么是直接内存
	直接内存是在系统内存中划出一块数据缓冲区，java代码可以直接使用，虽然分配成本高，但是读写性能高。不受JVM内存回收管理。
5. 一次完成的GC过程
	垃圾回收算法必须要实现识别垃圾以及清除垃圾的方法
	识别垃圾 可以使用引用计数法，给每一个对象添加引用计数器，引用数为0表示对象死亡，但是存在循环引用不能识别的情况。 目前比较主流的是可达性分析， 从一系列GC root的对象为起点，搜索传递引用，当一个对象没有跟任何一个GC引用链相连，表示该对象不可用，需要被回收。
	清除垃圾 标记-清除 用识别算法进行标记，随后清除掉死亡对象， 清除速度，慢且容易产生大量碎片。标记-复制，将内存分为大小相同的两块， 在标记接收后将不需要回收的对象复制到另一半的内存，该方法不产生碎片， 复制效率也高于清除，但使得内存减半。 标记-整理，在标记清除的基础上增加了整理这一步骤，避免碎片产生，但是回收效率低。
	堆内存被分为 Eden  Survivor old， 前两者属于新生代，后者是老年代。
	对象优先会在Eden区进行分配，当Eden区已满，出发一次young GC，进行新生代的垃圾回收，随后将Eden区依旧存活的数据加入到Survivor，Survivor中的对象每经过一次young GC没有被清除，年龄就会加1，当它年龄增加到15岁， 会被转移到老年代。 当老年代满了，则会触发full GC，清理整个堆内存。

为什么分代收集
只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。
6. 对象创建过程
	1. 类加载检查
	2. 分配内存
3. 初始化零值
4. 设置对象头
5. 执行初始化方法
7. 垃圾回收器  CMS 收集器 G1收集器
CMS低停顿垃圾回收器 是一个并发收集器， 也就是垃圾收集线程和用户线程同时工作。
1. 初始标记 暂停用户线程，标记Gcroot直接相连的对象，速度很快
2. 并发标记 同时开启GC和用户线程，扫描整个堆中，标记所有不需要回收的对象
3. 重新标记 修正并发标记过程中，由于应用程序运行造成的标记变化
4. 并发清除
存在问题：CMS基于标记清除算法，会产生空间碎片
G1收集器
G1是一个全年代回收器， G1取消了物理层面的分代，将整个堆内存切分为相同大小的小内存块region，通过组合region来形成代。 每个region都会根据各种信息产生一个回收价值，G1通过跟踪region的回收价值，组合一些最有价值的region进行回收，避免整代回收，使得 G1 收集器在有限时间内可以尽可能高的收集效率，从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。
























四、计算机网络
1. TCP 三次握手
	三次握手：建立可靠连接通道。 客户端向服务器发送请求报文SYN，来询问是否能够建立链接， 服务端回复SYN 和ACK，客户端再发送ACK数据包，完成TCP三从握手，客户端和服务端可以正式传输数据。
不能两次握手的原因： 1. 服务器无法确认自己回复的带有序列号报文客户端是否接收。2. 防止已失效的请求报文突然又传到服务器造成错误
2. 什么是半连接队列，什么是SYN Flood攻击
	客户端伪造IP发送了大量的SYN包，请求服务器连接，服务器给无辜ip地址回复ACK SYN， 造成服务器有大量的连接处于SYN_RCVD状态。服务器的半连接队列是有限的，如果半队列满，也会出现无法处理正常请求的情况
3. 什么是TFO  TCP Fast Open
	TCP快速打开，主要就是使用cookie标志客户端，在第二次建立连接时，请求连接报文中包含携带cookie的数据请求，服务端验证cookie有效性后，建立连接，并回复请求，这样就去除了一个往返的RTT
4. 如何理解TCP的keep-alive
就是TCP连接已经建立，但是客服端可能发生意外，导致下一个数据包永远不会到来，这个TCP连接就失效了，需要被清理。
5. TCP 时间戳主要解决的问题
1.计算往返时延 
2. 防止序列号回绕。 TCP序列号用32个bit表示 ，因此在2^32字节的数据传输之后，序列号会溢出回绕，那么相同序列号的包可以通过时间戳进行区分
6. 四次挥手断开连接
	客户端向服务端发送FIN包请求关闭连接， 服务器回复ACK包，进入关闭等待状态， 此时服务器还可以发送未发送的数据，客户端还可以接收数据，服务器结束发送数据，发送FIN包，进入最后确认状态，客户端收到之后回复ACK包并进入超时等待状态， 经过超时等待后关闭连接， 服务端收到ACK包之后立即关闭连接
	为什么客户端需要等待超时时间？为确保对方已收到ACK包。假设客户端发送完ACK包之后立即断开连接，而这个包在传输过程中丢失了，服务端就会一直处于最后确认状态。客户端发送ACK包之后等待一段时间，如果服务端没有收到ACK就会重发FIN包，客户端相应FIN包，重发ACK包，并刷新超时时间。
7. TCP 传输可靠性保障
	前提：一般网络是否五连续的传输任意长的数据，应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。
1. 使用校验和校验，确保数据包在传输过程中没有被修改。
2. 利用序列号解决接收端报文乱序问题
3. 利用应答确认机制，确定数据被正确接收，在合理的往返时延内没有收到确认消息，对应的数据包被假设为已丢失，并进行重传，解决丢包问题
以上确保了TCP传输的可靠性，提高TCP的传输效率
1. 发送等待确认再发送的应答确认协议被称为停等协议，网络吞吐量低。使用流水线协议会提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。收到三个相同的确认号，不必等待超时时间，进行快速重传
2. TCP使用滑动窗口机制实现了流量控制，通过考虑接收方的处理能力，动态调整发送端窗口大小，控制发送方的发送速率。
3. TCP定义拥塞窗口的变量进行拥塞控制，拥塞窗口的大小取决于网络的拥塞程度，发送窗口等于拥塞窗口和接收方的接收窗口小的那一个。TCP 的拥塞控制采用了四种算法，即 慢开始、 拥塞避免、快重传 和 快恢复。
慢启动，刚接入网络时，发送少量数据包探测网络情况，再一点一点增加发送包的数量。cwnd 初始值为 1，每经过一个RTT，cwnd 加倍。当网络发生拥堵时慢启动结束，或者是达到慢启动阈值，慢启动转为拥塞避免线性增长直到网络拥堵。
网络拥堵分为超时重传和三次确认， 前者说明网络拥塞严重，TCP将慢启动阈值变为当前拥塞窗口一半后, 把拥塞窗口大小设置为1，开启慢启动。
三次确认，网络轻微拥堵，使用快重传和快恢复算法。1. 将慢启动阈值更新为当前拥塞窗口一半并重传丢失的数据包 2.当前拥塞窗口的大小设置为当前慢启动阈值+3，再次收到重复ACK， 窗口加一， 当收到新数据的ACK，拥塞窗口设置为慢启动阈值，进行线性的拥塞避免。 
8. TCP与 UDP的区别

9. 什么时候选择 TCP，什么时候选 UDP?
UDP 一般用于即时通信，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。
TCP 用于对传输准确性要求特别高的场景，比如文件传输、发送和接收邮件、远程登录等等
10. HTTP和HTTPS的区别
	HTTP 是基于TCP的网络通信协议，使浏览器工作更为高效，HTTPS使HTTP的加强版，以TCP作为底层协议，额外使用SSL/TLS协议进行加密和安全认证
	HTTP连接是无状态的， HTTPS的安全性更高，但HTTP是免费的，HTTPS需要申请证书，证书是收费的，HTTP默认端口80， HTTPS默认端口443. 相比HTTP， HTTPS的握手协议更为费时，会影响服务的响应速度和吞吐量。
11. cookie 与 session的区别
	   服务器第一次收到客户端请求之后，会在服务器内存开辟一个session空间，创建一个session对象并且返回session id， 客户端的就会用cookie保存这个session id， 之后每次客户端发送请求时，都会携带session id， 就可以获取服务器上的以下会话，比如用户的登录状态。如果客户端没有cookie，session是无法进行身份验证的。
	在分布式的服务器级群中，session应该怎么扩展
	1. session黏贴， 同一个客户端的请求发送至同一个服务器， 负载不均衡，服务器挂了， session丢失
	2. session复制， 将session复制到所有服务器，耗时且容易丢失信息
3.session共享， 将session信息保存在第三方数据库。
12. 在地址栏键入URL后,网络世界发生么什么?
	1. 浏览器解析用户输入的URL，生成一个HTTP合适的请求
	2. 使用DNS进行域名解析，得到IP地址
	3. 建立TCP连接，发送HTTP请求
4.该请求将被路由到相应的控制器。控制器负责接收请求并解析请求参数，以确定需要执行的操作。
控制器会调用业务逻辑层中的方法来处理请求。业务逻辑层根据具体的业务需求，可能会调用数据访问层来获取或更新数据。
数据访问层负责与数据存储（如数据库）进行交互，执行数据库查询、插入、更新或删除等操作。
业务逻辑层根据数据访问层的结果进行逻辑处理，并生成处理结果。
处理结果通常会被封装到一个模型对象中，该模型对象包含了需要在视图中展示的数据。
控制器将模型对象和视图名称返回给前端，以便浏览器进行渲染。视图使用模型中的数据来生成最终的HTML、JSON或其他响应。
最后，浏览器接收到响应并进行渲染，将生成的页面展示给用户。
13. HTTP的缓存机制
	缓存目的：避免资源的重复申请
	HTTP1.0
	将资源存储在本地缓存中，再次请求时，若本地资源没有过期则直接使用本地转存中的资源，如果资源过期，则向服务器请求，若资源的最后修改时间没有发生变化，服务器返回304 表明缓存中的资源可以继续使用。
HTTP1.1
本地时间不一定可靠，缓存过期判断不一定准确.使用资源最后一次修改时间判断资源是否发生变化，存在ABA问题。 HTTP1.1 使用相对时间代替绝对时间，增加Etag即资源的Hash值，检查资源变更。


五、操作系统
1. 什么是操作系统
os是负责协调计算机硬件和软件资源工作的系统软件

2. 内核态与用户态
内核态与用户态：内核态（系统态）与用户态是操作系统的两种运行级别。内核态拥有最高权限，可以访问所有系统指令；用户态则只能访问一部分指令。
什么时候进入内核态：共有三种方式：a、系统调用。b、异常。c、设备中断。其中，系统调用是主动的，另外两种是被动的，设备中断时外来中断比如说读取数据读取结束了。
为什么区分内核态与用户态：在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。所以区分内核态与用户态主要是出于安全的考虑。

3. 进程线程和协程


4. 什么时候使用多进程，什么时候使用多线程
1.频繁修改：需要频繁创建和销毁的优先使用多线程 
2.计算量：需要大量计算的优先使用多线程 因为需要消耗大量CPU资源且切 换频繁，所以多线程好一点 
3.相关性：任务间相关性比较强的用多线程，相关性比较弱的用多进程。因为 线程之间的数据共享和同步比较简单。 
4.多分布：可能要扩展到多机分布的用多进程，多核分布的用多线程。 但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。
5. 为什么线程切换开销比进程小
进程的PCB，进程控制模块是加载到内核空间的，多个线程的入口地址（程序段所在的地址）都放在了PCB的线程表中，随后操作系统为该进程分配内核栈，为该线程分配用户栈，用于程序执行过程中数据的放置。每一个线程都由自己的用户栈，用存储自己的断点信息，线程间的切换，进程保存一下自己的断点，CPU将入口地址寄存器切换一下就可以了，不涉及内核中进程PCB的改变。但是进程之间的切换就设计到资源的各种切换。
6. 什么是僵尸进程，什么是孤儿进程

7.进程调度方法
1.先进先出FIFO（作业，进程）
按照任务进入队列的顺序，依次调用，执行完一个任务再执行下一个任务， 只有当任务结束后才会发生切换。平均响应时间高。耗时只需10毫秒的任务若恰巧在耗时1000毫秒的任务 后到来，他则需要1010毫秒才能执行完成，绝大部分时间都花在等待被 调度了。
2.短作业优先  （作业，进程）
优先调度耗时短的任务，长作业可能被饿死
3.优先调度（作业，进程）
 给每一个进程分配优先级，随着时间推移，增加等待进程的优先级
4.时间片轮转法（进程）
给队列中的每个任务一个时间片，第一个任务先执行，时间片到了之后，将 此任务放到队列尾部，切换到下个任务执行，这样能解决SJF中耗时长任务 饥饿的问题。多次切换，时间片不好设置，设置短了调度开销大，设置长了，退化成先进先出
5.多级反馈队列（进程）
设置多个就绪队列，优先级从高到低，每个队列时间片从小到大，进程在第一个队列没执行完，就会被移到下一个队列。前面队列不为空时，不执行后续队列进程。 快速响应，就算是长作业也会再第一个队列中执行一次，越前面的队列的优先级越高，保证了短作业的优先，优先级越高的队列时间片越短，那么执行的速度越快，优先级低的长作业依旧可以得到执行，批处理作业用户周转时间短。

8.  进程间的通信方式
	1. 管道： 管道适用于连接读/写进程的共享文件（pipe文件），本质上是内存中固定大小的缓冲区
	2. 共享内存：多个进程使用同一个共享空间
	3. 消息队列：点到点发送，广播信箱 
	4. 套接字： ，每个套接字由一个ip地址以及一个端口号，通过网络通信的每对进程由一对套接字
	5. 信号量： 允许N个线程在同一时刻访问同一资源


9 进程内存分配

首次适应最常用


10 分页 分段
分页把内存空间划分为大小相等且固定的块，把每一个进程也以块为单位进行划分，通过一个页表进行一一对应，用到的时候调入内存，不用的时候调回磁盘。只有最后一个页框可能会产生碎片，分了一个块但是用不完. 页表查询你需要两次访存，第一次查页表，第二次通过页表查页框。
分段把用户进程的地址空间按照模块进行划分（二维）主程序，子程序，公共资源。分段的颗粒度比分页大一点，所以信息共享更好，并且根据程序员的逻辑进行分段可以更好的提供服务。


11 什么是段页式
	程序逻辑分段，实际内存存储分页。 进程--> 段表-- > 页表--> 内存物理地址

12 快表查询
	加缓存避免反复查页表导致的两次访存
1.计算页面号，偏移量
2.去TLB看看之前记录的页面号与物理地址的对应关系，如果寄存器中有，那么根据物理地址一次访存
3.如果是头一次访问，还是要查询页表，进行两次访存，然后把这个对应关系写进TLB
 
进程切换时，这个TLB时要清空的，下次还需要重新建立，那么切换的消耗就非常大。

12. 虚拟内存管理
	虚拟内存：程序不要全部装入就可以运行，运行时根据需要进行动态装入。内存一共四个g，依赖虚拟性可以跑超过4个g的程序。

14 虚拟内存怎么实现
	作业运行时，仅装入当前要执行的部分页，发生缺页中断时， 将该页装入内存。如果转为满了，就会执行页面置换算法把不需要的页面换出去。

15 页面置换算法
	
16 DMA技术
 
传统I/O过程：
1.CPU发指令给磁盘控制器
2.磁盘控制器准备数据并讲数据放入磁盘控制器內部缓冲区，产生一个中断信号
3.CPU讲数据读进自己寄存器，随后把寄存器数据写入内存，在数据传输过程中CPU无法执行其他任务
存在问题： 大量读取太浪费CPU的时间
 
DMA（直接访问内存） 放在磁盘和CPU中间，数据搬运的工作DMA来做。
1.CPU将IO请求发送给DMA，自己该干嘛干嘛
2.DMA将请求发给磁盘
3.磁盘控制器将数据读入自身内部缓冲区向DMA产生一个中断信号
4.DMA将磁盘控制器中的数据拷贝到内核缓冲区
5.DMA读取数据结束之后就发中断信号给CPU
6.CPU将数据从内核拷贝到用户空间。
 
 
如果服务端要提供文件传输的功能，我们需要将磁盘上的文件读取出来，然后通过网络协议发送给客户端。 四次用户态和内核态的切换，四次数据拷贝。
1.DMA将磁盘上的数据拷贝到内核缓冲区
2.CPU将内核缓冲区数据拷贝到用户缓冲区
3.CPU将用户区的数据拷贝到Socket发送缓冲区
4.DMA将socket缓冲区中的数据拷贝到网卡缓冲区里
这个过程中 2，3是没有必要的，因为用户空间是不会对数据进行加工的。
 
零拷贝（Zero-copy）技术：因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。
1.mmap+write 省第二步  还是四次切换
2.send_file 省第三步，两次切换
3.SG_DMA 直接中内核缓冲区使用DMA发到网卡缓冲区 真正的0拷贝


六、数据库

范式
1NF 属性不可分
2NF 消除了非主属性对于码的部分依赖
解释： 表内数据 学号 姓名课号 成绩 ，主码为学号以及课号，但是姓名只依赖于学号，这就是非主属性的部份依赖
3NF 消除了非主属性对于码的传递依赖  
解释：表内数据 学号 姓名 系号 系主任  主码学号， 系号依赖于学号，系主任依赖于系号，造成传递依赖

引擎：
1. 什么是数据库的索引引擎
存储引擎负责处理数据的存储和检索，决定了数据在磁盘上的物理组织方式、索引结构、数据缓存、事务处理、并发控制等。不同的存储引擎在实现这些功能上可能采用不同的算法和策略，具有不同的性能和特性。

2.MyISAM与InnoDB的对比
MyISAM不支持事务，准确的说不具备原子性，发生错误不能回滚。使用表级锁，并发性差
InnoDB支持事务，可以进行数据库异常崩溃后的安全恢复，行级锁，并发性高
两者都使用b+树实现索引，但是MyISAM 索引和数据文件分离， InnoDB中数据文件本身就是索引文件


索引：
1. 什么是索引
	是一种快速查询和检索数据的数据结构， 但是创建索引和维护索引都需要耗费时间，索引还耗费一定空间，所以要恰当选择索引。
2. 创建索引的原则
	（1）选择经常用于查询排序分组连接操作的列作为索引列
	（2）如果该字段频繁被更新，不适合创建索引。因为需要频繁维护索引
	（3）如果不能有效区分数据的字段，不适合创建索引
	（4）有外键的列，一定要创建索引。这样的情况一般是为了链表查询或者子查询，创建索引会加速这一过程
	（5）查询中比较设计设字段，或者是重复值比较多的列，不要建立索引
（6）创建联合索引要根据最左前缀匹配原则，将最频繁使用的列放在最前面
3. 什么是最左前缀匹配原则
	最左前缀匹配原则是用于联合索引的情况下，对于索引中的字段，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配。在B树索引结构中，索引数据是按照键值的顺序存储的，每个叶子节点上的键值都是有序的。这种有序性使得在进行范围查询时，无法直接利用后面的索引。对于一个联合索引（A, B, C）来说，如果执行一个范围查询，比如WHERE A > 10，那么索引树只能找到A > 10的第一个叶子节点，并无法直接确定B、C列所对应的索引位置。因为后续的B和C列的值可能在该节点之后的其他叶子节点上。
（单独建一个联合索引树， 单纯的索引A 索引B 索引C是不能及逆行联合索引的）

4. 聚簇索引和二级索引（非聚簇索引的区别）
聚簇索引：数据存储和索引放在一起，找到索引就能找到数据，查询效率高，但是进行数据删除或者修改时，需要跟新索引树，增加系统开销
非聚簇索引：不存储真正的数据，只包含一个指向数据行的指针，需要回表。但数据删除或者修改时不需要更新索引树。
B+树就是非聚簇索引，他的索引结构存储指向实际行的指针，但是叶节点存储了完整的数据即查询结果，那么就不需要进行回表查询，这种索引也称为覆盖索引。
覆盖索引：索引"覆盖"了查询所需的数据

5. 索引失效的情况
	1. 模：使用模糊查询like并以%开头，这表示可以匹配任意字符，索引失效
	2. 型：数据类型错误  比如说明明是char数据非要去用int查
	3. 数：对索引字段使用内部函数， 比如说索引存储的是小写字符串，在查询时用upper转换成大写了
	4. 空：索引列为空
5. 运：索引列进行运算了
6. 最：联合索引中的最左匹配原则
7. 快：预计全表查询比索引快，就不用索引了 

6. 索引的数据结构

1.Hash索引：Hash索引使用散列函数将索引键映射到一个散列值，并将该散列值与索引项关联。Hash索引适用于等值查询，可以在O(1)时间复杂度内进行查找。然而，Hash索引不适用于范围查询，也不能排序，并且对于散列冲突（不同键值映射到同一个散列值）的处理方式需要额外的开销。、
2.平衡二叉树：查询时间O（logn）, 但是如果范围查询， 比如说查找大于5， 它要回溯遍历所有范围内的节点。并且插入和删除都需要对数进行调整，耗费资源和时间
3.B树，多叉树结构，每个节点可以包含多个键和对应的数据，相比于平衡二叉树的高度变矮，但是依旧没有解决回旋查找的问题
4.B+树，相比于b树，非叶子节点只存关键字信息，所有具体数据都存在叶子结点中。叶子节点通过链表连接，形成有序的数据序列，便于范围查询和遍历操作


事务
1. 什么事务
事务时逻辑上的一组操作，要么都执行，要么都不执行。事务可以保证对多个数据库进行操作时的数据一致性。
2. 事务四大特性 ACID
		原子性： 事务是最小的执行单位，不可分割
		一致性： 执行事务前后，数据保持一致
		隔离性： 事务之间相互独立，互不影响
		持久性： 事务操作完成后的数据将保存，并长期存在
	
3. 并发事务破坏了隔离性，带来以下问题
脏读：事务读取了其他事务未提交的数据。 事务A修改变量，该过程对其他事务可见 事务B读取了该变量的值，但是事务A发生意外回滚，事务B读取的是脏数据
丢失修改：两个事务读入同一个数据并进行修改，其中一个的提交结果破坏了另一个的提交结果
不可重复读： 一个事务短时间内读取同一个数据，该数据丢失，或者内容发生了改变
幻读：一个事务短时间内读取某一个范围的数据，但是数据行数多了
4. 事务隔离级别
		未提交读
		已提交读 避免了脏读       行锁
		可重复读：对于同一个字段的多次读取结果是一致的，除非被自身事务修改    行锁
		可序列化：最高隔离级别，事务逐个执行，互不干扰       表锁
		补充：mysql默认可重复读






锁： 解决并发问题
1. 锁的分类
（1）粒度不同
行锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
表锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
全局锁：是对整个数据库实例加锁。使用场景一般在全库逻辑备份时
（2）从数据库管理的角度对锁进行划分
共享锁（S锁）：又称为读锁，是读取操作（SELECT）时创建的锁。其他用户可以并发读取数据，但在读锁未释放前，也就是查询事务结束前，任何事务都不能对数据进行修改（获取数据上的写锁），直到已释放所有读锁。
	排他锁（X锁）：又称为写锁/独占锁，如果事务A对数据B加上写锁后，则其他事务不能再对数据B加任何类型的锁。
	意向锁：是表级锁，快速得知该表内是否有行锁。意向锁是数据引擎自己维护的，在为数据行加共享或者排他锁之前，InooDB会先获取该数据行所在数据表对应的意向锁
（3）从程序员的角度
悲观锁，认为数据出现冲突的可能性更大，直接在操作数据时，抢占锁。其他的事务在进行时就会等待，直到占有锁的事务释放锁为止。
乐观锁，认为大部分情况不会出现冲突，只有当数据去执行修改情况时，才会针对数据冲突做处理。版本号机制或 CAS 算法实现。
1. 版本号，数据每次更新，版本号都会更新，记下初始时的版本号，要修改前查看版本号，跟之前的不一样就说明有其他线程修改了该数据，本线程不再更新，更新失败
2. CAS算法，思路是用三个变量：需要读写的内存位置V、进行比较的预期原值A、拟写入的新值B，
如果位置V的值仍为预期的A时说明没有其他线程改动它，可以修改为新值B，否则不做修改

4. 死锁的四个条件以及解决方法
1.互斥条件：至少有一个资源被一个进程独占使用，该资源不能被其他进程访问。
2.请求保持条件：一个进程至少已经占有一个资源，同时还在等待其他进程所占有的资源。
3.不可抢占条件：已经分配给一个进程的资源不能被其他进程抢占，只能由占有资源的进程主动释放。
4.循环等待条件：存在一个进程资源的循环链，每个进程都在等待下一个进程所占有的资源。
只有当这四个条件同时满足时，才会产生死锁。
	1. 破坏请求保持条件， 在第一次执行 一次性申请所有的共享资源
	2. 破坏不可抢占条件， 占据资源的线程去申请资源时，如果申请失败则主动释放自己占有资源
	3. 破坏循环等待条件， 按照顺序分配资源

5 MVCC 解决原子性 持久性
作用：频繁的加锁，导致读数据时，没办法修改，修改数据时，没办法读取，大大降低了数据库性能。使用多版本并发控制来实现对数据库的并发访问。
	方式：
	（1）事务版本号， 事务每次开启前，都会从数据库获得一个自增长的事务ID，可以利用事务ID判断事务执行的先后顺序
	（2）每一行数据增设两个隐式字段， 一个记录当前操作该数据的事务ID， 以及指向回滚段的undo日志的指针
	（3）undo回滚日志，用于记录数据被修改前的信息。在表数据修改之前，会把数据拷贝到undo日志里，如果事务回滚，即可通过undo log进行数据还原
	（4）多个事务并行操作某一行数据时，不同事务对该行数据的修改产生了多个版本，这些版本通过回滚指针连成了一个链表。事务通过undolog读取数据。
	（5）数据可见性。每一个事务会生成一个read view，保存了当前没有提交的事务编号，通过事务之间的id来判断哪一个版本的数据时自己可见的。


百万级数据查询过慢怎么进行优化

1. 查询优化（怎么创建查询以及怎么避免所以失效）
	1, 利用最左前缀匹配原则创建索引
	2. 在查询时不要dui 索引进行处理， 要采用正确的索引类型，否则索引失效
	3. 索引不要在范围查询右边，索引会失效
	4. 模糊查询 like  %开头，索引失效  
	5. 少使用 select*会查到很多不必要的字段，浪费性能 
	6. 少用order by， order by 不能直接以用索引，他会将查询结果复制到内存中，对数据进行排序。当数据量非常大的时候，内存消耗大。可以创建覆盖索引进行优化。
假设有一个名为"users"的表，包含字段"id", "name", "age"等。现在想要按照年龄（age）字段进行升序排序，并只返回id和age字段的结果。创建一个包含age字段和其他需要的字段的覆盖索引， 编写查询语句并使用覆盖索引，数据库就会根据覆盖索引筛选和排序。

CREATE INDEX ON users (age, id);
SELECT id, age FROM users ORDER BY age ASC;
2.读写分离：经典的数据库拆库方案，主库负责写，从库负责读。主从复制时实现读写分离的一种常用方式，主节点将写操作的日志或者数据变更记录发送给从节点，从节点更新自己的副本数据，从而保持主从节点之间的数据一致性，从节点能够独立的处理读请求，减轻了主节点的负载。
	
3. 数据库结构优化（分库分表）：
分库分表是将一个大型数据库按照某种规则分成多个小型数据库，每个数据库甚至可以部署在不同的物理服务器上，并将数据表按照某种规则进行拆分。这样做的目的是为了将数据分散存储，提高数据库的并发处理能力和查询性能。
水平拆分是指将数据行按照某个规则分散到不同的数据库中。例如，可以按照用户ID或日期范围将数据分散到不同的数据库中，每个数据库只负责处理一部分数据。单库的数据量减少，但是导致管理复杂需要进行分布式管理和维护，包括数据的迁移，备份等操作更为复杂
垂直拆分是指将数据列按照某种规则分散到不同的表或数据库中。例如购物场景，可以将商品用户订单拆成三个表。减少了每个表字段的数目，提高查询性能，但是主键冗余，需要连表查询

其他：
1. MySQL 执行一条查询语句的内部 执行过程？
连接器：客户端先通过连接器连接到 MySQL 服务器。 
缓存：连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。
分析器：分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。 
优化器：优化器是对查询语句进行优化处理，例如一个表里面有多个索引， 优化器会判别哪个索引性能更好。
执行器：优化器执行完就进入执行器，执行器就开始执行语句进行查询比对 了，直到查询到满足条件的所有数据，然后进行返回。

2. 什么是触发器
触发器（trigger）是与表相关的数据库对象，是用户定义在关系表上的一类由事件驱动的特殊的存储过程，在满足定义条件时触发，并执行触发器中定义的 语句集合。触发器的这种特性可以协助应用在数据库端确保 数据库的完整性。
使用场景：如A，B两个表之间数据相关，修改A表则可以通过触发器自发的来修改B表。


七、Redis

1. redis 与 mysql的区别
Redis和MySQL是两种不同类型的数据库，有以下几个主要区别：

数据模型：Redis是一个基于键值对的内存数据库，数据存储在内存中，可以持久化到磁盘。它支持多种数据类型，如字符串、哈希、列表、集合和有序集合。MySQL是一个关系型数据库，使用表格的结构来存储和管理数据。
存储方式：Redis将数据存储在内存中，以提供快速的读写性能，但受限于内存大小。MySQL则是将数据存储在硬盘上，读写性能相对较低，但可以存储大量数据。
数据持久性：Redis可以通过将数据快照存储到磁盘或使用日志来实现数据持久化，以便在重启后恢复数据。MySQL则提供了持久化存储引擎（如InnoDB），可以保证数据在宕机后不会丢失。
查询语言：Redis使用类似于键值对的命令来访问和操作数据，其功能较为简单。MySQL则支持完整的SQL查询语言，具有更复杂的查询和操作能力。
数据一致性：Redis是单线程的，保证了数据的原子性和一致性。MySQL则是多线程的，支持并发操作，但可能会出现数据不一致的情况。
适用场景：由于Redis具有高速的读写性能和丰富的数据结构，适用于缓存、会话管理、消息队列等高性能和高并发的场景。而MySQL适用于需要复杂查询、事务处理和数据一致性的场景，如存储用户信息、订单数据等应用。

需要根据具体业务需求来选择使用Redis还是MySQL，有时候它们也可以结合使用来满足不同的需求。

补充：
1. redis是单线程还是多线程
 Redis 是单线程模型。Redis在IO操作上只是用单个线程处理客户端请求。尽管Redis是单线程，但是它通过非阻塞 I/O 和异步操作来实现高性能和高并发。Redis 单线程会不断地处理多个客户端的请求。此外由于redis是单线程模型，避免了多线程之间的锁竞争以及上下文切换的开销，提高可性能。
2. redis 6.0有哪些改进

3. I/O 多路复用I/O服务器可以使用一个线程来监视多个客户端连接的读写事件。当有任何一个客户端连接有数据可读或可写时，服务器线程会立即进行相应的处理，例如接收消息或发送消息

2.  Redis 的不同数据结构的应用场景
1.字符串 (String)：用于存储单个值的数据结构。适用于缓存、计数器、短期存储等场景。例如，将用户 token 存储在 Redis 的字符串中，用于身份验证和会话管理。
2.哈希 (Hash)：用于存储键值对的数据结构。适用于存储对象、用户属性、配置信息等场景。例如，将用户的详细信息存储在 Redis 的哈希中，每个用户对应一个哈希，可以方便地对个别用户的属性进行读写操作。
3.列表 (List)： 双向链表，用于存储有序的元素列表的数据结构。适用于消息队列、实时聊天等场景。例如，将用户产生的事件以列表的形式存储在 Redis 中，如用户发表的消息、点赞的内容等。
4.集合 (Set)：用于存储无序且唯一的元素的数据结构。适用于去重、共同好友、标签系统等场景。例如，用 Redis 的集合来存储用户的标签，可以方便地进行交集、并集和差集等操作。
5.有序集合 (Sorted Set)：压缩列表和跳跃表，用于存储有序且唯一的元素的数据结构，每个元素都会关联一个分数。适用于排行榜、社交网络的关注列表等场景。例如，将用户的积分排行榜存储在 Redis 的有序集合中，通过分数进行排序和查询。



相关问题：
1.什么是跳跃表
 		跳表是一种有序链表的扩展形式，通过添加多级索引来加速搜索。每一级索引是原始链表的一个子集，最高级索引是全局有序的。跳表在查询时，通过跳过部分节点，从而加快查找速度。跳表的平均查询时间复杂度为O(log N)，并且不需要进行平衡操作，适用于较小规模的有序数据集合。

2.跳表与红黑树与b+树
		首先三者都可以实现有序数据集合，并且实现确切值的快速查找。但是在范围查找上，红黑树需要先找到第一个值，随后回调中序遍历，跳表和b+树最下面一层是链表，所以可以直接顺序查找。
跳表和b+树都采用多级索引提高检索效率，但是由于用途的不同，两者在结点设计上不同。
B+树是在磁盘中寻找数据，为了减少磁盘IO操作，所以每个索引结点会指向一个磁盘页。B+树的叶子结点通常是一个双向链表，满足向前查询的要求。Redis是内存数据库，不需要考虑io操作，跳跃表相对简单，是有序链表的扩展形式，不需要树的平衡操作，很适用于较小规模的有序数据集合。

3.SDS是什么 simple dynamic strings
 		Redis底层使用SDS（Simple Dynamic Strings）作为字符串对象的表示，Redis自己实现的一种动态字符串数据结构。设计一个结构题，len表示字符串长度，free表示当前剩余可用空间长度，char buf用于存储字符串内容。向sds追加内容时，如果剩余内存不足，sds回重新分配更大的内存空间，将字符串复制过去。
typedef struct{
		int len;
		int free;
		char buf[ ]
}sds;

4.set的底层实现是什么
	 Intset：整数集合，内部是一个有序数组，元素按升序排序，且元素不重复，在元素比较小的时候可以使用，比较节约内存空间。
	 Hashtable, 就是我们常常说的键值对存储，插入，删除，查找的平均时间为o(1)，非常适合存储大型的非整数set数据


3. 为什么给缓存数据设置过期时间
	1. 控制缓存数据的生命周期， 我们的业务场景就是需要某个数据只在某⼀时间段内存在，⽐如我们的短信验证码可能只 在 1 分钟内有效，⽤户登录的 token 可能只在 1 天内有效。
	2. 及时清理缓存，缓解内存消耗

4. 过期数据的删除策略
	1. 惰性删除 ：只会在取出 key 的时候才对数据进⾏过期检查。对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。 
2. 定期删除 ： 每隔⼀段时间抽取⼀批 key 执⾏删除过期 key 操作，对内存友好。
注： 为防止大量过期key堆积在内存，Redis 内存淘汰机制保证了有限内存中保存的都是热点数据

5. redis内存淘汰机制
1.LRU（Least Recently Used，最近最少使用）：Redis 会优先淘汰最近最少使用的键，即最长时间没有被访问的键。这种策略通常能够较好地保留经常使用的数据。
2.LFU（Least Frequently Used，最不经常使用）：Redis 会优先淘汰最不经常使用的键，即访问次数最少的键。这种策略适用于频繁访问的数据。这个是最常⽤的。
3.Random（随机淘汰）：Redis 随机选择要淘汰的键，以保持数据的随机性。这种策略相对简单，但不能保证淘汰掉最少使用的键。
4. ttl 将将要过期的数据淘汰

6. Redis 持久化机制
	1.RDB(redis database)通过创建快照来获得存储在内存⾥⾯的数据在某个时间点上的副本进行保存，
	2.AOF(append only file)将 Redis 服务器接收到的每个写操作追加到日志文件中来持久化数据

7.redis 事务 不满足原子性 不满足持久化
	Redis 的原子性仅保证在单个命令或事务的执行层面上， resis将多个命令打包，然后按照顺序执行，中途不会被打断。在运行错误的情况下，其他命令是可以正常执行的。持久化是指在数据发生故障或者重启后仍能够被恢复，redis不支持事务回滚，所以不满足持久化。

8.  什么是缓存击穿、缓存穿透、缓存雪崩
缓存击穿：访问频率高的key称为热k， 指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到数据库。
缓存穿透：查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。
解决方法：对于不存在的数据，可以在缓存中设置一个空值，或者使用布隆过滤器等机制来过滤掉恶意请求，避免缓存穿透。布隆过滤器是一种通过位数组和一系列哈希函数实现的空间效率高，快速判断元素是否存在的数据结构。
缓存雪崩：指缓存中数据大批量到过期时间，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至down机。与击穿的区别在于 击穿针对某一热点key缓存，雪崩则是很多key
	解决办法：对热点数据设置适当的过期时间，避免缓存击穿。设置合理的缓存过期时间分布，避免所有数据同时失效，从而避免缓存雪崩。缓存雪崩的兜底措施，使用熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。

9 高并发下redis应该注意什么
	1.连接池管理，避免频繁创建和断开拦连接，减少连接开销
	2.并发控制，适当使用分布式锁，避免数据竞争和冲突
	3.批量处理，采用事务或者管道提高吞吐量
	4.根据业务需求选择合适的过期时间和淘汰策略，防止缓存击穿，穿透，雪崩
	5.可以采用本地缓存，缓解高并发下的redis负载压力，但是有可能会出现数据不一致的问题
	6.注意持久化策略，防止出现宕机，导致数据无法恢复

10.什么是redis集群
Redis 集群是一种高可用的分布式部署方案。在redis集群中，主节点接收各种来自客户端的需求，，对于读操作，主节点会根据哈希槽找到对应的子节点进行处理，并将处理结果返回客户端，这样可以利用多个子节点的计算能力，实现请求的并发处理。对于写操作，主节点会进行本地处理，保证数据的一致性和正确性，随后将写操作发送给所有子节点进行复制，主从复制确保主节点和子节点的数据一致



11.什么是哈希槽
Redis哈希槽（Redis Cluster Slot）是Redis Cluster（Redis集群）使用的一种数据分片机制，用于将数据均匀地分散存储在多个Redis节点中。哈希槽将数据集划分为固定数目的槽位，主节点通过对键进行哈希运算得到对应的槽位编号。当集群中的节点数目发生变化时，集群进行数据的迁移和重新分配。

12.什么是分布式锁
分布式锁就是用于分布式系统中，协调多个节点对共享资源的访问的。主节点负责获取锁和释放锁的操作。具体如下：
·1. 一个节点需要访问共享资源时，会在redis中设置一个特定键，表示上锁，该节点完成访问后，删除该键，这样其他的节点就有机会获取锁并访问共享资源。
2. 为了避免死锁，设置锁的持有时间，如果一个节点在锁过期时，依旧没有释放锁，那么锁自动过期。 但是操作共享资源的任务没有完成就被其他节点获得锁，可能引发数据不一致的问题。可以使用续期锁，更新锁过期时间

13. 主从复制的数据不一致问题
在redis集群中，redis数据主从复制是异步进行的，同步还没结束，主节点发起读请求，可能会导致读取旧值的问题。 检查网络连接，确保主从节点之间的网络稳定， 其次就是监控主从节点状态，如果系统对这个不是很敏感的话，可以不管。


你了解 ZooKeeper吗
因为我没有做过分布式系统，我对zookeeper了解不多。我只知道我项目中使用的kafka消息队列是依赖于zookeeper的， 它似乎是可以作为分布式锁保证分布式系统能够同步访问某个资源，可靠性比较好。












八、Spring
1. 什么是Spring框架：
	Spring是一个轻量级的JavaEE框架，它通过依赖注入和面向切面编程，使得开发者更专注业务逻辑的实现，而无需关注过多底层细节。 64 

2. Spring Boot相较于 Spring有什么区别
Spring boot是一个基于spring框架的开发框架，旨在简化spring程序搭建和部署。首先，spring boot 采取约定优于配置这样一个理念，大大简化了spring应用程序的搭建和维护。约定优于配置也就是使用约定规则来自动配置，使得开发者不需要进行繁琐的xml配置, 从而关注于业务逻辑设计。其次spring boot内置了常用的应用服务器，使得项目部署方便。Springboot还提供了大量的staters组件（开箱即用的依赖包），方便集成各种常用的框架和中间件，比如说redis 消息队列等。

3. 如何理解Spring IoC
Spring IoC 控制翻转，是一种设计思想，将对象的创建和管理的控制权从应用程序代码中反转到Spring容器中。这样做的好处是，我们解除了对对象创建和管理的责任，只需关注业务逻辑的实现。容器负责确保对象的创建和组装，保证它们在需要时可用，并且可以灵活地配置和管理对象的行为。

4. 如何理解Spring AOP
Spring AOP 可以让你通过给现有代码添加切面，实现额外的功能和行为，而不需要修改原有的代码，从而提高了代码的重用性、可维护性和可扩展性。想象一下你写了一个方法，用于处理用户登录的逻辑。现在，你希望在每次用户登录前后记录日志。使用 Spring AOP，你可以创建一个切面，其中包含了记录日志的逻辑。然后，你只需要告诉 Spring，在哪些地方需要应用这个切面，比如在用户登录方法上。Spring AOP 会自动在用户登录方法执行前后，执行你定义的切面逻辑，从而实现了日志记录的功能，而不需要修改原有的用户登录方法。

5. spring中bean的生命周期是什么
1.实例化（Instantiation）：在这个阶段，Spring 容器创建对象的实例。根据配置和需要，可以使用构造函数或工厂方法来实例化对象。
2.属性赋值（Property assignment）：在实例化完成后，Spring 容器会自动将配置文件中定义的属性值注入到对象中，以完成依赖注入。这可以通过 Setter 方法、字段注入或构造函数注入来实现。
3.初始化（Initialization）：在属性赋值完成后，Spring 容器会调用对象中定义的初始化方法，以执行一些额外的初始化操作。这可以通过实现 InitializingBean 接口或在 XML 配置文件中指定 init-method 来实现。
4.使用（In Use）：在对象初始化完成后，Spring 容器将对象置于可用状态，供其他对象或组件使用。在这个阶段，对象可以被其他对象调用和操作。
5.销毁（Destruction）：当 Spring 容器关闭或对象不再被使用时，容器会自动调用对象的销毁方法，以销毁对象并释放相关资源。这可以通过实现 DisposableBean 接口或在 XML 配置文件中指定 destroy-method 来实现。

6. 解释一下Spring中的循环依赖问题。
循环依赖指两个或多个Bean之间相互引用，形成了一个无限循环调用的情况。在Spring容器中，如果存在循环依赖，但是都是单例模式的Bean，则可以通过Spring容器提前暴露正在创建的Bean，从而避免循环依赖问题。如果存在循环依赖且其中一方是原型模式的Bean，则Spring无法处理这种情况。

7. 什么是Spring MVC，是什么工作流程
Spring MVC是一个基于表现层的框架。它专注于处理Web应用程序的请求和响应，并且提供了一种模型-视图-控制器（Model-View-Controller）的架构模式。在Spring MVC中，模型用于存储和处理数据，视图用于展示数据，而控制器则处理请求并决定响应的行为。通过使用Spring MVC，可以将业务逻辑与表现层（前端）进行分离，使得开发人员能够更好地管理和维护代码。 
Spring MVC的运作流程如下：1. 客户端（浏览器）发送一个HTTP请求到DispatcherServlet。
2. DispatcherServlet是Spring MVC的核心控制器，它选择合适的处理器来处理
3. 处理器（Controller）接收请求并处理它，通常会进行一些业务逻辑的处理，然后生成一个Model（模型）对象，可以包含页面需要的数据。4. 处理器将Model对象和视图名称返回给DispatcherServlet。5. DispatcherServlet使用ViewResolver（视图解析器）来根据视图名称找到合适的视图对象。视图对象可以是JSP页面、Thymeleaf模板、Freemarker模板等。6. DispatcherServlet将Model对象传递给视图对象，并且执行视图的渲染过程。渲染过程将Model中的数据填充到视图模板中，生成最终的HTML响应。7. 最终生成的HTML响应通过HTTP响应发送回客户端（浏览器）。
8. 什么是MyBatis
MyBatis是一个持久层框架，提供了一种简单灵活的方式将java对象与关系数据库中的对象进行映射。具体方式是注解和xml 


九、仿牛客项目总结
1. 结构
本项目是一个基于Spring Boot的论坛网站，实现了用户注册、登录、发帖、点赞、系统通知和搜索等基本功能。为了实现这些功能，我们采用了一些关键的技术和框架。首先，我们使用了Spring MVC作为项目的表现层框架，用于处理Web应用程序的请求和响应。Spring MVC提供了一个灵活的模型-视图-控制器的架构，让我们可以更好地组织和处理用户请求。其次，我们使用了MyBatis作为持久化框架，通过XML或注解的方式配置SQL映射关系，实现与数据库的交互。除此之外，我们还采用了Spring Security来处理身份验证和权限管理。Spring Security是一个功能强大的安全框架，它提供了多种身份认证方式和授权管理机制，使我们能够保护用户数据的安全，并对不同用户进行细粒度的权限控制。通过整合这些技术和框架，我们构建了一个完善的论坛网站。 
另外引入了redis数据库来提升网站的整体性能，实现了用户凭证的存取、点赞关注的功能。基于 Kafka 实现了系统通知：当用户获得点赞、评论后得到通知。利用定时任务定期计算帖子的分数，并在页面上展现热帖排行榜。

2. 技术栈的细节实现
	1. 首先我们使用redis作为缓存，以提升系统的性能。Redis是基于内存模型额高性能数据库。我们使用redis来缓存高频访问的功能信息，比如说点赞，评论，关注等。此外，我们利用redis存储短时间使用的验证码，通过设置缓存时间，有效管理其使用。此外我们把用户信息缓存到redis，减轻数据库的负载，加快用户信息的读取速度。
	2. 我们使用kafka消息系统使用实现了发送系统通知的频繁操作。具体流程是：创建一个事务类，创建消息生产类能够将消息发送给消息队列，创建消费者类，执行具体的消费逻辑。在程序启动时，kafka创建监听器，开始监听指定的主题，在我们点赞，评论，关注的时候，应用程序创建事务对象发送到消息队列中。监听器从队列中拉取消息，随后执行响应的处理方法。
	3. 我们使用Elasticsearch进行全文搜索。Elasticsearch文档存储是一个专门的全文搜索引擎，并发处理，分布式搜索，使他能够高效的处理大量数据。本项目中在原有的数据库实体上增加注解，实现mysql向es的索引映射。使用异步双写，当数据库中的数据发生变化时，发送kafka消息，随后上传该数据对之前的旧数据进行覆盖。


3. 网站的优化
	1 使用拦截器实现网站独立访客数以及日用户活跃数的功能。功能的具体实现依托于两种redis特殊的数据结构，是HyperLogLog，是一种概率性数据结构，用于估计一个集合的基数，误差在0.81%左右，不能估计精确值，但是速度快，占用空间小。另一个是Bitmap，位图，使用通过使用二进制来表示每个布尔值，可以快速计算一个集合的元素个数。
	2. 热度排行榜功能实现。这里我们使用的是quartz 作业调度框架定期的修改帖子的热度值以实现帖子根据热度排序的功能。配置 jobdetail trigger信息， 将配置信息保存到数据库中，只要开始程序就会询问数据库开始定时任务。
	3. 使用Caffeine缓存来提升帖子列表和帖子总数的查询性能，减少对数据库的访问。具体流程在@PostConstruct注解的init()方法中，通过Caffeine.newBuilder()创建了Caffeine缓存对象，并配置了缓存的最大大小和失效时间。同时，通过build()方法传入了一个CacheLoader对象，用于定义当缓存数据不存在时，如何从数据库中加载数据并放入缓存





项目问题：
1. 登陆状态是怎么确定的
	（1）http是无状态的，每个请求都是独立的，服务器并不会记住之前的请求和客户端状态，所以需要使用cookie或者seesion记录登录状态
	（2）cookie是服务器发送给用户浏览器并保存在本地的一小块数据，在后续请求中，浏览器会自动将cookie发送给服务器。通常是用来告知服务器是否来自于同一个服务器
		Session是存储在服务器上的数据，是通过cookie实现的。具体而言，当用户第一次访问网站时，服务器会创建一个唯一的会话标识符（Session ID），通常是一个随机生成的字符串。服务器会将这个Session ID发送给浏览器并存储在Cookie中，以便在后续的请求中将该Session ID发送回服务器。服务器根据这个Session ID来查找对应的会话数据，并根据需要更新或获取相关的用户状态信息。
	（3）登录信息只需要穿一个ticket，如果用session在存，占据内存资源不说，在分布式服务器上还会需要拓展性问题，所以我们选择使用cookie存储用户登录的ticket信息。
	（4）服务器需要对cookie携带的登录信息进行验证，则需要一个记录用户登录信息的数据库。我们可以考虑redis数据库，key为登录凭证值为用户对象。也可以使用表进行存储，但是访问速度会慢一点，需要连表查询。
	 (5) 根据登录与否主页上显示的信息会有不同，这是一个通用功能，我们采用拦截器，拦截浏览器访问请求，进行统一的登录信息验证	
		
具体实现过程：
	1. 用户登陆成功，服务器生成一个登录凭证，将凭证作为key， 相关的用户信息作为值存放再redis中，随后将登录凭证发送给浏览器，浏览器保存该cookie
	2. 浏览器再次发送请求时，拦截器拦截所有需要验证身份的请求。拦截器从请求中读取cookie,获取用户的登陆凭证，去redis验证，判断该身份凭证是否有效。
	3. 如果身份凭证有效，则将用户信息存储到ThreadLocal中，拦截器将请求传递给后续的服务，业务逻辑就可以直接从ThreadLocal中获取用户信息。
	4. 请求结束后，将ThreadLocal中的用户信息清除，防止内存泄漏，这个过程也是通过拦截器进行。

补充：为什么用ThreadLocal存储用户对象
	ThreadLocal是当前线程的本地变量， 不同线程的用户对象不互相打扰，保证了线程的安全性。将对象存储在ThreadLocal中，同一个线程的同一个线程的不同方法就可以访问到该用户对象。


2.AOP用在哪   统一处理日志
在传统编程中，我们使用类和对象组织代码，把相关的功能集中在类中，但是有一些功能是横跨多个类的额对象的，比如说日志记录，安全性检查，不是核心业务，但是必须要存在。AOP思想就是将横跨多个类和对象的共同点从核心业务逻辑中分离出来，以提高代码的可重用性。拦截器还有过滤器都体现了AOP的思想。我们项目中使用Spring AOP实现日志的统一处理。 定义一个日志记录的切面（Aspect），定义一个切点（Pointcut），表示切面逻辑用于哪个位置，随后定义日志记录逻辑。切面类使用@Aspect， 切点 @Pointcut，  @Before， @after这种注解表示切面逻辑的具体位置

Spring AOP 的常见方法是动态代理，程序运行时，Spring容器会扫描并解析所有的切面和切点，创建代理对象，将切面逻辑添加到中间，这些对象会保存在spring 容器里，在整个程序生命周期中重复使用。当程序执行到切点的时候，代理对象就会被调用，并执行切面逻辑。 
 
假设有一个名为UserService的用户服务类，其中有一个方法名为getUserInfo()。假设我们希望在执行getUserInfo()方法之前打印一句话。使用Spring AOP，我们可以创建一个切面类，其中定义了@Before通知注解修饰的before()方法，该方法包含了切面逻辑。当调用userService.getUserInfo()方法时，实际执行的是userService的代理对象。代理对象会在执行getUserInfo()方法之前，先执行切面逻辑，即before()方法。然后再执行getUserInfo()方法的业务逻辑。（向原逻辑中加代码）


3.项目中redis是怎么用的
（1）缓存点赞和关注： 用户点赞数用string 进行自增 自减， 实体点赞数用set存储点赞的用户，那么之后就可以显示点赞列表。粉丝列表用的是zset可以按照关注时间进行排序
（2）优化了登录程序
	1. 使用redis进行登录凭证缓存
	2. 用户信息的缓存， 获取ueser时，先从redis中获取，取不到再去数据库中查询，缓存到redis中。编程数据时，先更新数据库，再清理缓存
	3. 使用redis进行验证码的缓存，可以供服务器快速读取和验证，还可以设置过期时间控制有效其期限。 
（3）redis用到事务管理了吗
	在缓存点赞中用到了事务管理， 点赞涉及到实体点赞数和点赞对象两个值的变化。
（4）怎么保证redis和数据库的一致性
	本项目中，使用的只读缓存， 如果有数据新增，会直接写进数据库，有数据删改时，更新数据库，清除缓存中的数据。服务器再次访问这些删改数据时，缓存没有响应的数据，就会从数据库中将数据读入缓存。
	这种方法的问题在于，如果缓存删除失败，导致请求再次访问缓存时，取得的是旧值，造成数据的不一致性
	1. 用事务保证两个操作的原子性，要么同时成功，要么同时失败，如果失败了就进行重试。 Redis支持事务但是不支持事务回滚，可以采用消息队列的方法， 执行失败后重新进入队列
	2. 延迟双删：延迟双删策略则是在第一次删除后，根据业务情况延迟一定时间再进行一次删除，以求最大程度的保证数据一致性。但需要注意的是，延迟的时间不能过长也不能过短：如果延迟的时间较大，那么在延迟期间内请求到的数据可能

4. 项目中怎么用kafka
	1. 我们需要实现在收获点赞 评论 关注时发送系统通知，发送系统通知这一操作非常频繁，用户群体很多，需要考虑性能问题
	2.我们可以使用消息队列来实现消息的异步传输。解耦发送者和接收者之间的关系，提高系统响应速度。
这里我们采用的是， kafka是一个分布式的发布订阅消息系统。它具有高吞吐量，高可靠性，高扩展性。因为他是分布式的，所以不同服务器可以并行处理消息，服务器不够时，可以增加服务器，使用磁盘存储数据， 过副本机制（Replica）提供了数据的冗余和容错保证了消息的可靠性。
	3.为什么kafka速度快
		数据写入方面：虽然kafka将数据写进硬盘中，但是kafka使用顺序IO，避免磁盘寻址。Kafka不是实时写入数据， 批量处理，多个消息一起写入，减少了IO次数。
		数据读取方面：kafka使用b+树索引加速消息的查找，，使用页缓存来缓存磁盘上的数据
		Kafka还采用了使用零拷贝避免数据在内核和用户空间的复制， 直接将数据从磁盘读取到应用程序的内存空间或者是直接把应用内存空间数据传出到磁盘
	4. 方法流程： 创建一个事务类，创建消息生产类能够将消息发送给消息队列，创建消费者类，执行具体的消费，逻。 具体流程如下：程序启动时，kafka创建监听器，开始监听指定的主题，在我们点赞，评论，关注的时候，应用程序创建事务对象发送到消息队列中。监听器从队列中拉取消息，随后执行响应的处理方法。



其他问题
1. 消息队列和阻塞队列是一种东西吗
消息队列（Message Queue）是一种用于在应用程序或系统之间传递消息的机制。它可以将消息从一个发送者发送到一个或多个接收者。解耦发送者和接收者之间的关系，进行异步通讯，独立的进行信息处理，提高了系统的吞吐量和响应能力。
堵塞队列是一种特殊类型的队列，队列为空或队列已满时自动阻塞等待。
堵塞队列是消息队列的一种实现形式，但是消息队列不一定使用堵塞队列实现。

2. kafka分布式发布-订阅消息系统
	（1） 发布订阅消息系统：发布者负责产生消息并发布到指定的主题中，不需要关心具体的接收者，订阅者则通过订阅感兴趣的主题来接收消息，需要关注消息来源。发送者和接收者依赖关系解耦，适用于各种异步通信。一个消息可以被多个订阅者接收，实现了消息的广播和多播的功能。
	（2）Kafka通过分区（Partition）实现了消息的并行处理和负载均衡.Kafka 中的每个主题（Topic）可以被分成多个分区，每个分区是一个有序且不可变的消息序列。分区就是消息队列中的队列。不同的分区可以被分布在不同的 Kafka broker 节点上，使得多个消费者可以并行地读取和处理消息，实现高吞吐量和低延迟。
	（3）Kafka 通过副本机制（Replica）提供了数据的冗余和容错性。每个分区可以有多个副本，其中一个为领导者副本（Leader Replica），其余的为追随者副本（Follower Replica）。领导者副本负责处理所有的读写请求，并保持与追随者副本之间的同步。追随者副本通过与领导者副本保持同步，提供冗余和容错能力。如果领导者副本发生故障，追随者副本可以自动选举一个新的领导者来继续服务。
	（4）kafka 将消息持久化到磁盘中，便面消息丢失的风险
	（5）Kafka 采用批量处理和零拷贝技术，提高了消息的传输效率和性能

	
5. 项目中使用Elasticsearch 分布式搜索引擎
	1. 为什么用es，不使用mysql直接进行全文搜索
		如果没有相关性匹配需求，也就是那种发散性的搜索结果，当数据量比较少，或者是对时间要求比较低时，可以通过使mysql中的like操作符进行模糊查询或者是mysql的全文搜索。但是如果数据量大，like需要逐个比较文档中的字符寻找匹配结果的执行速度变慢，并且需要一些发散思维进行内容的分析，那么mysql就不够用了。我们这里采用Elasticsearch 专门的全文搜索引擎进行搜索。
	2. es为什么快
	ES则是文档存储。文档可以类似于mysql中的一行数据，文档时json格式的，可以是一个产品，文章，用户或者时任一个结构化的实体。ES使用倒排索引可以快速的定位包含特定词的文档。倒排索引就是记录了每一个单词对应的文档编号。我们按照词语进行搜索就变得非常容易。此外es是并发处理，分布式搜索，使他能够高效的处理大量数据。
	3. 怎么使用es进行搜索，如何将mysql中的数据同步到es中
	    在我们原有数据库实体上增加注解，实现mysql向es索引的映射。
		在本项目中，使用的是异步双写。当数据库中的数据发生改变时，会发送kafka消息，随后对上传该数据对es旧数据进行覆盖。
	
	4. es并发量很大时怎么办
	 1.硬件优化 2 集群扩展 3.合理分片并发处理。


6. 为什么要用Spring Security
作用： 之前，登录界面是在MVC框架中的control实现的，身份的再次验证是通过拦截器实现的。但是对于相对复杂且安全要求高的场景下，就不够用了，比如说第三方登录，以及一些权限控制， 我们可以采用Sprng Security实现统一的身份验证以及访问控制。当然它还具有防护攻击，加密等功能。

执行流程：用户请求会被Spring Security的过滤器链进行拦截，紧接着，请求会依次通过多个过滤器进行信息和权限验证。验证失败会进行重定向，比如说没有登录就想要访问某个功能，会重定向到登录页面，如果没有使用这一功能权限，会转到错误或者是权限不足的页面。验证成功则会返回一个Authentication认证对象，其中包含用户账户密码以及相关权限，之后会存在服务器的会话中，随后服务器返回一个会话id给浏览器。之后第二次验证时就可以使用这个会话id验证用户的状态。

技术细节： 用户实体类implement UserDetails 重写用户权限类型
		 用户服务类implement UserDetailsService 重写user获取 其实就是与数据库信息交互
		 继承WebSecurityConfigurerAdapter进行认证方法配置，登录配置， 退出配置，授权配置，以及记住我
		 在主页控制controller中SecurityContextHolder获取用户信息



spring 线程池  在application.properties 配置线程池的属性， 定义public方法， 使用@Async注解。处理任务阶段，注入ThreadPoolTaskExecutor对象执行异步任务。定时任务使用@Scheduled注解


quartz 作业调度框架
1.Job（作业）：表示要执行的任务或操作。Quartz提供了Job接口，开发者需要实现该接口的execute方法来定义作业的具体逻辑。
2.JobDetail（作业详细信息）：用于描述作业的基本信息和特征，如作业的名称、组名、关联的Job实例等。
3.Trigger（触发器）：用于定义作业的执行时间规则。Quartz提供了多种触发器类型，如SimpleTrigger（简单触发器）和CronTrigger（Cron表达式触发器）。
4.Scheduler（调度器）：负责管理和调度作业的核心组件。Scheduler提供了与作业相关的操作，如添加、删除、暂停、恢复和查询作业等。
Quartz使用分布式锁来确保在多分布式环境中，同一时刻只有一个节点可以访问和修改作业调度信息。这避免了多个节点同时对同一份作业调度信息进行修改，保证了数据的一致性和完整性。

配置 jobdetail trigger @bean 将配置信息保存到数据库中，只要开始程序就会询问数据库开始定时任务
# -
